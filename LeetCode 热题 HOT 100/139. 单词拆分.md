![image-20221117140717154](https://raw.githubusercontent.com/qkd90/figureBed/main/202211171407312.png)

## 分析

是否能够把原问题分解成规模更小，结构相同的子问题，然后通过子问题的结果计算原问题的结果?答案是肯定的，因此推测使用动态规划

1.确定dp数组定义：

我们定义 dp[i]表示字符串 s前 i个字符组成的字符串 s[0..i−1]是否能被空格拆分成若干个字典中出现的单词。

2.写出状态转移方程：

dp[i]=dp[j] && check(s[j..i−1])

![image-20221117153835940](https://raw.githubusercontent.com/qkd90/figureBed/main/202211171538014.png)

3.dp数组初始化

dp[0] = true表示空串且合法

4.遍历顺序

## 代码

```java
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordDictSet = new HashSet(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```

